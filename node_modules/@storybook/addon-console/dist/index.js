'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.setConsoleOptions = setConsoleOptions;
exports.withConsole = withConsole;

var _window = require('global/window');

var _window2 = _interopRequireDefault(_window);

var _addonActions = require('@storybook/addon-actions');

var _reactDecorator = require('./react-decorator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var logger = console; /** 
                       * It handles `console.log`, `console.warn`, and `console.error` methods and not catched errors. By default, it just reflects all console messages in the Action Logger Panel (should be installed as a peerDependency) except [HMR] logs.
                       * @module @storybook/addon-console 
                       * 
                       * 
                       */

var cLogger = {
  log: logger.log,
  warn: logger.warn,
  error: logger.error
};

/**
 * @typedef {Object} addonOptions - This options could be passed to [withConsole]{@link #storybookaddon-consolewithconsoleoptionsorfn--function} or [setConsoleOptions]{@link #module_@storybook/addon-console.setConsoleOptions}
 * @property {RegExp[]} [panelExclude = [/[HMR]/]] - Optional. Anything matched to at least one of regular expressions will be excluded from output to Action Logger Panel
 * @property {RegExp[]} [panelInclude = []] - Optional. If set, only matched outputs will be shown in Action Logger. Higher priority than `panelExclude`.
 * @property {RegExp[]} [consoleExclude = []] - Optional. Anything matched to at least one of regular expressions will be excluded from DevTool console output
 * @property {RegExp[]} [consoleInclude = []] - Optional. If set, only matched outputs will be shown in console. Higher priority than `consoleExclude`.
 * @property {string} [log = console] - Optional. The marker to display `console.log` outputs in Action Logger
 * @property {string} [warn = warn] - Optional. The marker to display warnings in Action Logger
 * @property {string} [error = error] - Optional. The marker to display errors in Action Logger
 */
var addonOptions = {
  panelExclude: [/\[HMR\]/],
  panelInclude: [],
  consoleExclude: [],
  consoleInclude: [],
  log: 'console',
  warn: 'warn',
  error: 'error'
};

var currentOptions = addonOptions;

var createLogger = function createLogger(options) {
  return {
    log: (0, _addonActions.action)(options.log),
    warn: (0, _addonActions.action)(options.warn),
    error: (0, _addonActions.action)(options.error)
  };
};

var shouldDisplay = function shouldDisplay(messages, exclude, include) {
  if (include.length) {
    return messages.filter(function (mess) {
      return typeof mess === 'string' ? include.find(function (regExp) {
        return mess.match(regExp);
      }) : false;
    });
  }
  if (exclude.length) {
    return messages.filter(function (mess) {
      return typeof mess === 'string' ? !exclude.find(function (regExp) {
        return mess.match(regExp);
      }) : true;
    });
  }
  return messages;
};

function setScope(options) {
  var panelExclude = options.panelExclude,
      panelInclude = options.panelInclude,
      consoleExclude = options.consoleExclude,
      consoleInclude = options.consoleInclude;

  var aLogger = createLogger(options);

  logger.log = function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var toPanel = shouldDisplay(args, panelExclude, panelInclude);
    var toConsole = shouldDisplay(args, consoleExclude, consoleInclude);
    if (toPanel.length) aLogger.log.apply(aLogger, (0, _toConsumableArray3.default)(toPanel));
    if (toConsole.length) cLogger.log.apply(cLogger, (0, _toConsumableArray3.default)(toConsole));
  };

  logger.warn = function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var toPanel = shouldDisplay(args, panelExclude, panelInclude);
    var toConsole = shouldDisplay(args, consoleExclude, consoleInclude);
    if (toPanel.length) aLogger.warn.apply(aLogger, (0, _toConsumableArray3.default)(toPanel));
    if (toConsole.length) cLogger.warn.apply(cLogger, (0, _toConsumableArray3.default)(toConsole));
  };

  logger.error = function () {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var toPanel = shouldDisplay(args, panelExclude, panelInclude);
    var toConsole = shouldDisplay(args, consoleExclude, consoleInclude);
    if (toPanel.length) aLogger.error.apply(aLogger, (0, _toConsumableArray3.default)(toPanel));
    if (toConsole.length) cLogger.error.apply(cLogger, (0, _toConsumableArray3.default)(toConsole));
  };

  _window2.default.onerror = function () {
    var toPanel = shouldDisplay([arguments.length <= 0 ? undefined : arguments[0]], panelExclude, panelInclude);
    var toConsole = shouldDisplay([arguments.length <= 0 ? undefined : arguments[0]], consoleExclude, consoleInclude);
    if (toPanel.length) aLogger.error.apply(aLogger, arguments);
    if (toConsole.length) return false;

    return true;
  };
}

setScope(addonOptions);

var detectOptions = function detectOptions(prop) {
  if (!prop) return {};
  if ((typeof prop === 'undefined' ? 'undefined' : (0, _typeof3.default)(prop)) === 'object') {
    var _newOptions = (0, _extends3.default)({}, prop);
    return _newOptions;
  }
  var newOptions = (0, _extends3.default)({}, prop(currentOptions)); // check: should it be currentOptions?
  return newOptions;
};

/**
 * This callback could be passed to {@link setConsoleOptions} or {@link withConsole}
 * 
 * @example 
 * import { withConsole } from `@storybook/addon-console`;
 * 
 * const optionsCallback = (options) => ({panelExclude: [...options.panelExclude, /Warning/]});
 * addDecorator((storyFn, context) => withConsole(optionsCallback)(storyFn)(context));
 *
 * @callback optionsCallback
 * @param {addonOptions} currentOptions - the current {@link addonOptions}
 * @return {addonOptions} - new {@link addonOptions}
 */

/**
 * Set addon options and returns a new one
 * @param {addonOptions|optionsCallback} optionsOrFn 
 * @return {addonOptions}
 * @see addonOptions
 * @see optionsCallback
 * 
 * @example
import { setConsoleOptions } from '@storybook/addon-console';

const panelExclude = setConsoleOptions({}).panelExclude;
setConsoleOptions({
  panelExclude: [...panelExclude, /deprecated/],
});
 */
function setConsoleOptions(optionsOrFn) {
  var newOptions = detectOptions(optionsOrFn);
  currentOptions = (0, _extends3.default)({}, currentOptions, newOptions);
  setScope(currentOptions);
  return currentOptions;
}

function handleStoryLogs() {
  switch (_window2.default.STORYBOOK_ENV) {
    case 'react':
      return _reactDecorator.reactStory;
    default:
      logger.warn('Warning! withConsole doesn\'t support @storybook/' + _window2.default.STORYBOOK_ENV + '. Use setConsoleOptions instead');
      return function (story) {
        return story;
      };
  }
}

function addConsole(storyFn, context, consoleOptions) {
  var prevOptions = (0, _extends3.default)({}, currentOptions);
  var logNames = context ? {
    log: context.kind + '/' + context.story,
    warn: context.kind + '/' + context.story + ' warn',
    error: context.kind + '/' + context.story + ' error'
  } : {};

  var options = (0, _extends3.default)({}, currentOptions, logNames, consoleOptions);

  setScope(options);
  var story = storyFn();
  var wrapStory = handleStoryLogs();
  var wrappedStory = wrapStory(story, function () {
    return setScope(options);
  }, function () {
    return setScope(currentOptions);
  });

  currentOptions = prevOptions;
  setScope(currentOptions);
  return wrappedStory;
}

/**
 * Wraps your stories with specified addon options.
 * If you don't pass {`log`, `warn`, `error`} in options argument it'll create them from context for each story individually. Hence you'll see from what exact story you got a log or error. You can log from component's lifecycle methods or within your story.
 * @param {addonOptions|optionsCallback} [optionsOrFn]
 * @see [addonOptions]{@link #storybookaddon-consolesetconsoleoptionsoptionsorfn--addonoptions}
 * @see [optionsCallback]{@link #storybookaddon-consoleoptionscallback--addonoptions}
 * @return {function} wrappedStoryFn
 * 
 * @example
 * import { storiesOf } from '@storybook/react';
 * import { withConsole } from '@storybook/addon-console';
 * 
 * storiesOf('withConsole', module)
 *  .addDecorator((storyFn, context) => withConsole()(storyFn)(context))
 *  .add('with Log', () => <Button onClick={() => console.log('Data:', 1, 3, 4)}>Log Button</Button>)
 *  .add('with Warning', () => <Button onClick={() => console.warn('Data:', 1, 3, 4)}>Warn Button</Button>)
 *  .add('with Error', () => <Button onClick={() => console.error('Test Error')}>Error Button</Button>)
 *  .add('with Uncatched Error', () =>
 *    <Button onClick={() => console.log('Data:', T.buu.foo)}>Throw Button</Button>
 *  )
 // Action Logger Panel:
 // withConsole/with Log: ["Data:", 1, 3, 4]
 // withConsole/with Warning warn: ["Data:", 1, 3, 4]
 // withConsole/with Error error: ["Test Error"]
 // withConsole/with Uncatched Error error: ["Uncaught TypeError: Cannot read property 'foo' of undefined", "http://localhost:9009/static/preview.bundle.js", 51180, 42, Object]
 */
function withConsole(optionsOrFn) {
  var newOptions = detectOptions(optionsOrFn);
  return function (storyFn) {
    return function (context) {
      return addConsole(storyFn, context, newOptions);
    };
  };
}